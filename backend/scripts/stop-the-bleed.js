#!/usr/bin/env node
/**
 * üö® STOP-THE-BLEED - MIGRATION OP√âRATIONNELLE V2
 * ===============================================
 * 
 * Script de migration d'urgence pour arr√™ter les collisions de contenu
 * et mettre en place le nouveau syst√®me UID/versioning.
 */

const mongoose = require('mongoose');
const fs = require('fs').promises;
const path = require('path');
const { exec } = require('child_process');
const { promisify } = require('util');

const execAsync = promisify(exec);

// Import des modules
const MigrationV2 = require('./migrate-to-v2');
const TestSystemV2 = require('./test-v2-system');

require('dotenv').config();

class StopTheBleed {
    constructor() {
        this.backupPath = path.join(__dirname, 'emergency-backup');
        this.logPath = path.join(__dirname, 'stop-the-bleed.log');
        this.steps = [];
    }

    /**
     * Logger avec timestamp
     */
    log(message, level = 'INFO') {
        const timestamp = new Date().toISOString();
        const logMessage = `[${timestamp}] [${level}] ${message}`;
        console.log(logMessage);
        this.steps.push(logMessage);
    }

    /**
     * Sauvegarder les logs
     */
    async saveLogs() {
        const logContent = this.steps.join('\n');
        await fs.writeFile(this.logPath, logContent);
        this.log(`Logs sauvegard√©s: ${this.logPath}`);
    }

    /**
     * √âTAPE 1: Freeze publication (mode lecture seule)
     */
    async freezePublication() {
        this.log('üîí √âTAPE 1: Freeze publication (mode lecture seule)', 'CRITICAL');
        
        try {
            // Cr√©er un fichier de verrou
            const lockFile = path.join(__dirname, '../.publication-lock');
            await fs.writeFile(lockFile, JSON.stringify({
                locked: true,
                timestamp: new Date().toISOString(),
                reason: 'Emergency migration to V2 system',
                operator: process.env.USER || 'system'
            }, null, 2));
            
            this.log('‚úÖ Mode lecture seule activ√©');
            this.log(`üìÅ Fichier de verrou cr√©√©: ${lockFile}`);
            
            // TODO: Ici vous pourriez aussi notifier votre syst√®me de monitoring
            // ou envoyer un webhook √† votre √©quipe
            
            return true;
            
        } catch (error) {
            this.log(`‚ùå Erreur lors du freeze: ${error.message}`, 'ERROR');
            throw error;
        }
    }

    /**
     * √âTAPE 2: Backup complet
     */
    async createBackup() {
        this.log('üíæ √âTAPE 2: Backup complet MongoDB + fichiers', 'CRITICAL');
        
        try {
            // Cr√©er le dossier de backup
            await fs.mkdir(this.backupPath, { recursive: true });
            
            // Backup MongoDB
            const mongoBackupPath = path.join(this.backupPath, 'mongodb');
            await fs.mkdir(mongoBackupPath, { recursive: true });
            
            const mongodumpCmd = `mongodump --uri="${process.env.MONGODB_URI}" --out="${mongoBackupPath}"`;
            this.log(`Ex√©cution: ${mongodumpCmd}`);
            
            const { stdout, stderr } = await execAsync(mongodumpCmd);
            if (stderr) this.log(`Warnings mongodump: ${stderr}`, 'WARN');
            
            // Backup des fichiers assets (si applicable)
            const assetsPath = path.join(__dirname, '../visual_cache');
            const assetsBackupPath = path.join(this.backupPath, 'visual_cache');
            
            try {
                await execAsync(`cp -r "${assetsPath}" "${assetsBackupPath}"`);
                this.log('‚úÖ Backup assets termin√©');
            } catch (error) {
                this.log(`‚ö†Ô∏è  Backup assets ignor√©: ${error.message}`, 'WARN');
            }
            
            this.log('‚úÖ Backup complet termin√©');
            this.log(`üìÅ Backup sauvegard√©: ${this.backupPath}`);
            
            return true;
            
        } catch (error) {
            this.log(`‚ùå Erreur lors du backup: ${error.message}`, 'ERROR');
            throw error;
        }
    }

    /**
     * √âTAPE 3: Audit et rapport des collisions
     */
    async auditCollisions() {
        this.log('üîç √âTAPE 3: Audit des collisions existantes', 'CRITICAL');
        
        try {
            await mongoose.connect(process.env.MONGODB_URI, {
                useNewUrlParser: true,
                useUnifiedTopology: true
            });
            
            const migration = new MigrationV2();
            await migration.connect();
            
            const auditResults = await migration.auditCollisions();
            const reportPath = await migration.generateCollisionReport();
            
            this.log(`üìä ${auditResults.totalQuestions} questions analys√©es`);
            this.log(`‚ö†Ô∏è  ${auditResults.collisions} collisions d√©tect√©es`);
            this.log(`üìã Rapport d√©taill√©: ${reportPath}`);
            
            await migration.disconnect();
            
            return auditResults;
            
        } catch (error) {
            this.log(`‚ùå Erreur lors de l'audit: ${error.message}`, 'ERROR');
            throw error;
        }
    }

    /**
     * √âTAPE 4: G√©n√©ration des QIDs et migration
     */
    async runMigration() {
        this.log('üîÑ √âTAPE 4: Migration vers syst√®me V2', 'CRITICAL');
        
        try {
            const migration = new MigrationV2();
            const results = await migration.runFullMigration();
            
            this.log(`‚úÖ ${results.migration.migrated} questions migr√©es`);
            this.log(`‚ùå ${results.migration.errors} erreurs`);
            
            if (results.migration.errors > 0) {
                this.log('‚ö†Ô∏è  Des erreurs de migration ont √©t√© d√©tect√©es', 'WARN');
                this.log('üìã Voir migration-errors.json pour les d√©tails');
            }
            
            return results;
            
        } catch (error) {
            this.log(`‚ùå Erreur lors de la migration: ${error.message}`, 'ERROR');
            throw error;
        }
    }

    /**
     * √âTAPE 5: Cr√©ation des index uniques
     */
    async createUniqueIndexes() {
        this.log('üóÇÔ∏è  √âTAPE 5: Cr√©ation des index uniques', 'CRITICAL');
        
        try {
            const QuestionV2 = require('../models/QuestionV2');
            
            // Les index sont d√©finis dans le sch√©ma, mais on peut les forcer
            await QuestionV2.collection.createIndex(
                { qid: 1, version: 1 }, 
                { unique: true, name: 'qid_version_unique' }
            );
            
            await QuestionV2.collection.createIndex(
                { bundleHash: 1 }, 
                { unique: true, name: 'bundle_hash_unique' }
            );
            
            await QuestionV2.collection.createIndex(
                { state: 1, type: 1, series: 1 }, 
                { name: 'state_type_series' }
            );
            
            this.log('‚úÖ Index uniques cr√©√©s');
            
            return true;
            
        } catch (error) {
            this.log(`‚ùå Erreur lors de la cr√©ation des index: ${error.message}`, 'ERROR');
            throw error;
        }
    }

    /**
     * √âTAPE 6: Tests de validation
     */
    async runValidationTests() {
        this.log('üß™ √âTAPE 6: Tests de validation du syst√®me V2', 'CRITICAL');
        
        try {
            const tester = new TestSystemV2();
            const results = await tester.runAllTests();
            
            this.log(`üìä Tests: ${results.passed}/${results.total} r√©ussis`);
            
            if (results.failed > 0) {
                this.log(`‚ö†Ô∏è  ${results.failed} tests √©chou√©s`, 'WARN');
                this.log('üìã Voir test-report-v2.json pour les d√©tails');
                
                // En cas d'√©chec critique, on peut d√©cider d'arr√™ter
                const criticalFailures = results.tests.filter(t => 
                    !t.passed && ['QID Uniqueness', 'Bundle Hash Uniqueness'].includes(t.name)
                );
                
                if (criticalFailures.length > 0) {
                    throw new Error(`Tests critiques √©chou√©s: ${criticalFailures.map(t => t.name).join(', ')}`);
                }
            }
            
            return results;
            
        } catch (error) {
            this.log(`‚ùå Erreur lors des tests: ${error.message}`, 'ERROR');
            throw error;
        }
    }

    /**
     * √âTAPE 7: Activation des validations API
     */
    async activateValidations() {
        this.log('üõ°Ô∏è  √âTAPE 7: Activation des validations API', 'CRITICAL');
        
        try {
            // Cr√©er un fichier de configuration pour activer les validations
            const configFile = path.join(__dirname, '../config/validation-config.json');
            const validationConfig = {
                enabled: true,
                strict: true,
                alphabetValidation: true,
                optionsValidation: true,
                bundleHashValidation: true,
                assetIntegrityCheck: true,
                activatedAt: new Date().toISOString()
            };
            
            await fs.mkdir(path.dirname(configFile), { recursive: true });
            await fs.writeFile(configFile, JSON.stringify(validationConfig, null, 2));
            
            this.log('‚úÖ Validations API activ√©es');
            this.log(`üìÅ Configuration: ${configFile}`);
            
            return true;
            
        } catch (error) {
            this.log(`‚ùå Erreur lors de l'activation des validations: ${error.message}`, 'ERROR');
            throw error;
        }
    }

    /**
     * √âTAPE 8: D√©freeze et nettoyage
     */
    async unfreeze() {
        this.log('üîì √âTAPE 8: D√©freeze et nettoyage', 'CRITICAL');
        
        try {
            // Supprimer le fichier de verrou
            const lockFile = path.join(__dirname, '../.publication-lock');
            try {
                await fs.unlink(lockFile);
                this.log('‚úÖ Mode lecture seule d√©sactiv√©');
            } catch (error) {
                this.log(`‚ö†Ô∏è  Fichier de verrou non trouv√©: ${error.message}`, 'WARN');
            }
            
            // Invalider le cache (si applicable)
            const cacheDir = path.join(__dirname, '../visual_cache');
            try {
                const cacheFiles = await fs.readdir(cacheDir);
                for (const file of cacheFiles) {
                    if (file.endsWith('.json')) {
                        await fs.unlink(path.join(cacheDir, file));
                    }
                }
                this.log('‚úÖ Cache vid√©');
            } catch (error) {
                this.log(`‚ö†Ô∏è  Nettoyage cache ignor√©: ${error.message}`, 'WARN');
            }
            
            return true;
            
        } catch (error) {
            this.log(`‚ùå Erreur lors du d√©freeze: ${error.message}`, 'ERROR');
            throw error;
        }
    }

    /**
     * V√©rification des pr√©requis
     */
    async checkPrerequisites() {
        this.log('‚úÖ V√©rification des pr√©requis...', 'INFO');
        
        const checks = [
            { name: 'MongoDB URI', check: () => !!process.env.MONGODB_URI },
            { name: 'mongodump disponible', check: async () => {
                try {
                    await execAsync('mongodump --version');
                    return true;
                } catch { return false; }
            }},
            { name: 'Espace disque suffisant', check: async () => {
                try {
                    const { stdout } = await execAsync('df -h .');
                    return !stdout.includes('100%');
                } catch { return true; } // Assume OK if can't check
            }}
        ];
        
        for (const check of checks) {
            const result = await check.check();
            this.log(`${result ? '‚úÖ' : '‚ùå'} ${check.name}: ${result ? 'OK' : '√âCHEC'}`, 
                    result ? 'INFO' : 'ERROR');
            if (!result) {
                throw new Error(`Pr√©requis non satisfait: ${check.name}`);
            }
        }
    }

    /**
     * Pipeline complet "Stop-the-bleed"
     */
    async execute() {
        this.log('üö® === D√âMARRAGE STOP-THE-BLEED ===', 'CRITICAL');
        this.log('Migration d\'urgence vers syst√®me V2', 'CRITICAL');
        
        const startTime = Date.now();
        
        try {
            // V√©rifications pr√©alables
            await this.checkPrerequisites();
            
            // √âtapes critiques
            await this.freezePublication();
            await this.createBackup();
            const auditResults = await this.auditCollisions();
            const migrationResults = await this.runMigration();
            await this.createUniqueIndexes();
            const testResults = await this.runValidationTests();
            await this.activateValidations();
            await this.unfreeze();
            
            const duration = Math.round((Date.now() - startTime) / 1000);
            
            this.log('üéâ === MIGRATION TERMIN√âE AVEC SUCC√àS ===', 'CRITICAL');
            this.log(`‚è±Ô∏è  Dur√©e totale: ${duration} secondes`, 'INFO');
            this.log(`üìä ${migrationResults.migration.migrated} questions migr√©es`, 'INFO');
            this.log(`üß™ ${testResults.passed}/${testResults.total} tests r√©ussis`, 'INFO');
            
            // R√©sum√© final
            const summary = {
                success: true,
                duration,
                audit: auditResults,
                migration: migrationResults.migration,
                tests: {
                    passed: testResults.passed,
                    failed: testResults.failed,
                    total: testResults.total
                }
            };
            
            const summaryPath = path.join(__dirname, 'stop-the-bleed-summary.json');
            await fs.writeFile(summaryPath, JSON.stringify(summary, null, 2));
            this.log(`üìã R√©sum√© sauvegard√©: ${summaryPath}`, 'INFO');
            
            return summary;
            
        } catch (error) {
            this.log(`üí• ERREUR CRITIQUE: ${error.message}`, 'CRITICAL');
            this.log('üìû INTERVENTION MANUELLE REQUISE', 'CRITICAL');
            
            // En cas d'erreur, on peut tenter un rollback automatique
            await this.emergencyRollback();
            
            throw error;
            
        } finally {
            await this.saveLogs();
            
            if (mongoose.connection.readyState === 1) {
                await mongoose.disconnect();
            }
        }
    }

    /**
     * Rollback d'urgence en cas d'√©chec
     */
    async emergencyRollback() {
        this.log('üîÑ ROLLBACK D\'URGENCE EN COURS...', 'CRITICAL');
        
        try {
            // Restaurer depuis le backup
            const mongoBackupPath = path.join(this.backupPath, 'mongodb');
            const restoreCmd = `mongorestore --uri="${process.env.MONGODB_URI}" --drop "${mongoBackupPath}"`;
            
            await execAsync(restoreCmd);
            this.log('‚úÖ Base de donn√©es restaur√©e depuis le backup', 'INFO');
            
            // Supprimer le verrou
            await this.unfreeze();
            
            this.log('‚úÖ Rollback termin√©', 'INFO');
            
        } catch (rollbackError) {
            this.log(`‚ùå Erreur lors du rollback: ${rollbackError.message}`, 'ERROR');
            this.log('üÜò INTERVENTION MANUELLE CRITIQUE REQUISE', 'CRITICAL');
        }
    }
}

// Ex√©cution si appel√© directement
if (require.main === module) {
    const stopTheBleed = new StopTheBleed();
    
    stopTheBleed.execute()
        .then((summary) => {
            console.log('\n‚úÖ Migration r√©ussie!');
            console.log('üìä R√©sum√©:', JSON.stringify(summary, null, 2));
            process.exit(0);
        })
        .catch((error) => {
            console.error('\nüí• Migration √©chou√©e:', error.message);
            console.error('üìã Consultez les logs pour plus de d√©tails');
            process.exit(1);
        });
}

module.exports = StopTheBleed;