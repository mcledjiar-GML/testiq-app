#!/usr/bin/env node
/**
 * üìä POST-CANARY CHECK (48h)
 * ==========================
 * 
 * V√©rifications post-d√©ploiement 48h apr√®s canary 100% :
 * - Z√©ro indice visible d√©tect√©
 * - R√©partition positions A/B/C/D ‚âà 25% ¬±2%
 * - Disponibilit√© ‚â• 99.9%
 * - Rapport canary 1 page
 */

const QuestionV2 = require('../models/QuestionV2');

class PostCanaryChecker {
    
    constructor() {
        this.results = {
            visibleHints: { detected: 0, issues: [] },
            positionDistribution: { balanced: false, distribution: {} },
            availability: { percentage: 0, compliant: false },
            alerts: { critical: 0, recurring: [] },
            summary: { allGreen: false, recommendations: [] }
        };
    }
    
    /**
     * V√©rifier z√©ro indice visible en production
     */
    async checkVisibleHints() {
        console.log('üîç V√©rification indices visibles...');
        
        const questions = await QuestionV2.find({ 
            state: 'published',
            updatedAt: { $gte: new Date(Date.now() - 48 * 60 * 60 * 1000) } // 48h
        }).lean();
        
        const hintPatterns = [
            /\b(r√©ponse|solution|correct)\b/gi,
            /^\s*[A-D]\s*[:.]|\([A-D]\)/gm,
            /\b[A-D]\s+(est|=)\s+(correct|vrai|faux)/gi,
            /(attention|note|indice|hint)\s*:/gi,
            /bonne\s+r√©ponse/gi
        ];
        
        let detectedCount = 0;
        
        questions.forEach(question => {
            let hasHint = false;
            
            // V√©rifier contenu principal
            if (question.content) {
                hintPatterns.forEach(pattern => {
                    if (pattern.test(question.content)) {
                        hasHint = true;
                    }
                });
            }
            
            // V√©rifier options
            if (question.options) {
                question.options.forEach((option, index) => {
                    if (option.content) {
                        hintPatterns.forEach(pattern => {
                            if (pattern.test(option.content)) {
                                hasHint = true;
                            }
                        });
                    }
                });
            }
            
            if (hasHint) {
                detectedCount++;
                this.results.visibleHints.issues.push({
                    qid: question.qid,
                    version: question.version,
                    locale: question.locale
                });
            }
        });
        
        this.results.visibleHints.detected = detectedCount;
        
        console.log(`${detectedCount === 0 ? '‚úÖ' : '‚ùå'} Indices visibles: ${detectedCount} d√©tect√©s`);
        
        return detectedCount === 0;
    }
    
    /**
     * V√©rifier r√©partition positions A/B/C/D
     */
    async checkPositionDistribution() {
        console.log('üìä V√©rification r√©partition positions...');
        
        const questions = await QuestionV2.find({ 
            state: 'published' 
        }).lean();
        
        const positionCounts = { A: 0, B: 0, C: 0, D: 0 };
        let totalWithCorrect = 0;
        
        questions.forEach(question => {
            if (question.options && question.options.length === 4) {
                const correctIndex = question.options.findIndex(opt => opt.isCorrect);
                if (correctIndex !== -1) {
                    const position = ['A', 'B', 'C', 'D'][correctIndex];
                    positionCounts[position]++;
                    totalWithCorrect++;
                }
            }
        });
        
        const distribution = {};
        let isBalanced = true;
        
        ['A', 'B', 'C', 'D'].forEach(pos => {
            const percentage = totalWithCorrect > 0 ? (positionCounts[pos] / totalWithCorrect) * 100 : 0;
            distribution[pos] = {
                count: positionCounts[pos],
                percentage: parseFloat(percentage.toFixed(1))
            };
            
            // V√©rifier ¬±2% de 25%
            if (Math.abs(percentage - 25) > 2) {
                isBalanced = false;
            }
        });
        
        this.results.positionDistribution = {
            balanced: isBalanced,
            distribution,
            totalQuestions: totalWithCorrect
        };
        
        console.log(`${isBalanced ? '‚úÖ' : '‚ùå'} R√©partition √©quilibr√©e: ${isBalanced ? 'OUI' : 'NON'}`);
        console.log(`   A: ${distribution.A.percentage}% B: ${distribution.B.percentage}% C: ${distribution.C.percentage}% D: ${distribution.D.percentage}%`);
        
        return isBalanced;
    }
    
    /**
     * V√©rifier disponibilit√© ‚â• 99.9%
     */
    async checkAvailability() {
        console.log('üìà V√©rification disponibilit√©...');
        
        try {
            const sloMonitoring = global.sloMonitoring;
            if (!sloMonitoring) {
                console.log('‚ö†Ô∏è SLO monitoring non disponible');
                return false;
            }
            
            const evaluation = sloMonitoring.evaluateSLOs();
            const availabilitySLO = evaluation.slos.availability;
            
            const percentage = availabilitySLO ? availabilitySLO.current : 0;
            const compliant = percentage >= 99.9;
            
            this.results.availability = {
                percentage: parseFloat(percentage.toFixed(3)),
                compliant,
                target: 99.9
            };
            
            console.log(`${compliant ? '‚úÖ' : '‚ùå'} Disponibilit√©: ${percentage.toFixed(3)}% (‚â•99.9% requis)`);
            
            return compliant;
            
        } catch (error) {
            console.error('‚ùå Erreur v√©rification disponibilit√©:', error.message);
            this.results.availability = { error: error.message };
            return false;
        }
    }
    
    /**
     * V√©rifier alertes critiques r√©currentes
     */
    async checkCriticalAlerts() {
        console.log('üö® V√©rification alertes critiques...');
        
        try {
            const monitoringSystem = global.monitoringSystem;
            if (!monitoringSystem) {
                console.log('‚ö†Ô∏è Monitoring system non disponible');
                return true; // Pas d'alertes = OK
            }
            
            const activeAlerts = Array.from(monitoringSystem.alerts?.activeAlerts || []);
            const criticalAlerts = activeAlerts.filter(alert => 
                alert.severity === 'critical' || alert.severity === 'emergency'
            );
            
            // Identifier alertes r√©currentes (> 3 occurrences en 48h)
            const alertCounts = {};
            criticalAlerts.forEach(alert => {
                const key = alert.type || alert.message;
                alertCounts[key] = (alertCounts[key] || 0) + 1;
            });
            
            const recurringAlerts = Object.entries(alertCounts)
                .filter(([_, count]) => count > 3)
                .map(([type, count]) => ({ type, count }));
            
            this.results.alerts = {
                critical: criticalAlerts.length,
                recurring: recurringAlerts,
                total: activeAlerts.length
            };
            
            const hasRecurring = recurringAlerts.length > 0;
            console.log(`${!hasRecurring ? '‚úÖ' : '‚ùå'} Alertes r√©currentes: ${recurringAlerts.length}`);
            
            if (hasRecurring) {
                recurringAlerts.forEach(alert => {
                    console.log(`   ‚Ä¢ ${alert.type}: ${alert.count} occurrences`);
                });
            }
            
            return !hasRecurring;
            
        } catch (error) {
            console.error('‚ùå Erreur v√©rification alertes:', error.message);
            return false;
        }
    }
    
    /**
     * G√©n√©rer rapport canary 1 page
     */
    generateCanaryReport() {
        const checks = [
            { name: 'Indices visibles', passed: this.results.visibleHints.detected === 0 },
            { name: 'R√©partition positions', passed: this.results.positionDistribution.balanced },
            { name: 'Disponibilit√© ‚â•99.9%', passed: this.results.availability.compliant },
            { name: 'Pas d\'alertes r√©currentes', passed: this.results.alerts.recurring.length === 0 }
        ];
        
        const allGreen = checks.every(check => check.passed);
        
        const report = {
            timestamp: new Date().toISOString(),
            deployment: 'TestIQ v5.0 Canary ‚Üí Production',
            duration: '48h post-deployment',
            status: allGreen ? 'SUCCESS' : 'ISSUES_DETECTED',
            
            summary: {
                allChecks: allGreen,
                totalChecks: checks.length,
                passedChecks: checks.filter(c => c.passed).length
            },
            
            checks: checks.map(check => ({
                name: check.name,
                status: check.passed ? 'PASS' : 'FAIL',
                passed: check.passed
            })),
            
            details: {
                visibleHints: this.results.visibleHints,
                positionDistribution: this.results.positionDistribution,
                availability: this.results.availability,
                alerts: this.results.alerts
            },
            
            recommendations: this.generateRecommendations(allGreen, checks),
            
            nextSteps: allGreen ? [
                'D√©ploiement canary consid√©r√© comme r√©ussi',
                'Surveillance continue recommand√©e',
                'Planifier prochaine release dans 2-4 semaines'
            ] : [
                'Investiguer probl√®mes identifi√©s',
                'Corriger avant prochaine release', 
                'Renforcer tests pr√©-d√©ploiement'
            ]
        };
        
        this.results.summary = {
            allGreen,
            report,
            recommendations: report.recommendations
        };
        
        return report;
    }
    
    /**
     * G√©n√©rer recommandations
     */
    generateRecommendations(allGreen, checks) {
        const recommendations = [];
        
        if (allGreen) {
            recommendations.push('‚úÖ D√©ploiement canary r√©ussi - Tous crit√®res respect√©s');
            recommendations.push('üéØ Maintenir surveillance continue des m√©triques');
            recommendations.push('üìä Analyser les patterns d\'usage apr√®s 1 semaine');
        } else {
            checks.forEach(check => {
                if (!check.passed) {
                    switch (check.name) {
                        case 'Indices visibles':
                            recommendations.push('üîß Nettoyer indices visibles d√©tect√©s');
                            break;
                        case 'R√©partition positions':
                            recommendations.push('üé≤ R√©ajuster randomisation positions correctes');
                            break;
                        case 'Disponibilit√© ‚â•99.9%':
                            recommendations.push('‚ö° Optimiser performance pour atteindre SLO');
                            break;
                        case 'Pas d\'alertes r√©currentes':
                            recommendations.push('üö® Investiguer causes alertes r√©currentes');
                            break;
                    }
                }
            });
        }
        
        return recommendations;
    }
    
    /**
     * Afficher r√©sultats console
     */
    displayResults() {
        console.log('\nüìä === RAPPORT POST-CANARY 48H ===');
        
        const report = this.results.summary.report;
        
        console.log(`\nüéØ Status: ${report.status}`);
        console.log(`‚úÖ Checks r√©ussis: ${report.summary.passedChecks}/${report.summary.totalChecks}`);
        
        console.log('\nüìã D√âTAILS:');
        report.checks.forEach(check => {
            const icon = check.passed ? '‚úÖ' : '‚ùå';
            console.log(`${icon} ${check.name}: ${check.status}`);
        });
        
        if (this.results.visibleHints.detected > 0) {
            console.log(`\n‚ö†Ô∏è Indices visibles: ${this.results.visibleHints.detected} d√©tect√©s`);
            this.results.visibleHints.issues.slice(0, 3).forEach(issue => {
                console.log(`   ‚Ä¢ Q${issue.qid} (${issue.locale})`);
            });
        }
        
        if (!this.results.positionDistribution.balanced) {
            console.log('\n‚ö†Ô∏è D√©s√©quilibre positions:');
            Object.entries(this.results.positionDistribution.distribution).forEach(([pos, data]) => {
                const deviation = Math.abs(data.percentage - 25);
                if (deviation > 2) {
                    console.log(`   ‚Ä¢ Position ${pos}: ${data.percentage}% (¬±${deviation.toFixed(1)}% de 25%)`);
                }
            });
        }
        
        console.log('\nüí° RECOMMANDATIONS:');
        report.recommendations.forEach(rec => {
            console.log(`   ${rec}`);
        });
        
        console.log('\nüöÄ PROCHAINES √âTAPES:');
        report.nextSteps.forEach(step => {
            console.log(`   ‚Ä¢ ${step}`);
        });
        
        return this.results.summary.allGreen;
    }
    
    /**
     * Ex√©cution compl√®te
     */
    async run() {
        console.log('üìä === POST-CANARY CHECK 48H ===\n');
        
        try {
            await this.checkVisibleHints();
            await this.checkPositionDistribution();
            await this.checkAvailability();
            await this.checkCriticalAlerts();
            
            this.generateCanaryReport();
            const success = this.displayResults();
            
            return { success, results: this.results };
            
        } catch (error) {
            console.error('üí• Erreur post-canary check:', error.message);
            throw error;
        }
    }
}

// Ex√©cution si appel√© directement
if (require.main === module) {
    const checker = new PostCanaryChecker();
    
    checker.run()
        .then(({ success }) => {
            console.log(`\nüéØ ${success ? '‚úÖ CANARY VALID√â' : '‚ùå PROBL√àMES D√âTECT√âS'}`);
            process.exit(success ? 0 : 1);
        })
        .catch(error => {
            console.error('üí• Erreur:', error);
            process.exit(1);
        });
}

module.exports = PostCanaryChecker;